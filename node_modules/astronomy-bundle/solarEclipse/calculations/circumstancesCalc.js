"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.circumstancesToJulianDay = exports.iterateCircumstancesMaximumEclipse = exports.getTimeLocalDependentCircumstances = exports.getTimeDependentCircumstances = void 0;
var angleCalc_1 = require("../../utils/angleCalc");
var coordinateCalc_1 = require("../../coordinates/calculations/coordinateCalc");
var besselianElementsCalc_1 = require("./besselianElementsCalc");
function getTimeDependentCircumstances(besselianElements, t) {
    var x = besselianElements.x, y = besselianElements.y, d = besselianElements.d, mu = besselianElements.mu, l1 = besselianElements.l1, l2 = besselianElements.l2;
    return {
        x: (0, besselianElementsCalc_1.populate)(x, t),
        dX: (0, besselianElementsCalc_1.populateD)(x, t),
        y: (0, besselianElementsCalc_1.populate)(y, t),
        dY: (0, besselianElementsCalc_1.populateD)(y, t),
        d: (0, besselianElementsCalc_1.populate)(d, t),
        dD: (0, besselianElementsCalc_1.populateD)(d, t),
        mu: (0, besselianElementsCalc_1.populate)(mu, t),
        dMu: (0, besselianElementsCalc_1.populateD)(mu, t),
        l1: (0, besselianElementsCalc_1.populate)(l1, t),
        dL1: (0, besselianElementsCalc_1.populateD)(l1, t),
        l2: (0, besselianElementsCalc_1.populate)(l2, t),
        dL2: (0, besselianElementsCalc_1.populateD)(l2, t),
    };
}
exports.getTimeDependentCircumstances = getTimeDependentCircumstances;
function getTimeLocalDependentCircumstances(besselianElements, location, t) {
    var tMax = besselianElements.tMax, t0 = besselianElements.t0, dT = besselianElements.dT;
    var lat = location.lat, lon = location.lon, elevation = location.elevation;
    var _a = getTimeDependentCircumstances(besselianElements, t), x = _a.x, dX = _a.dX, y = _a.y, dY = _a.dY, mu = _a.mu, dMu = _a.dMu, d = _a.d, dD = _a.dD;
    var rhoSinLat = (0, coordinateCalc_1.getRhoSinLat)(lat, elevation);
    var rhoCosLat = (0, coordinateCalc_1.getRhoCosLat)(lat, elevation);
    var muRad = (0, angleCalc_1.deg2rad)(mu);
    var dMuRad = (0, angleCalc_1.deg2rad)(dMu);
    var dRad = (0, angleCalc_1.deg2rad)(d);
    var dDRad = (0, angleCalc_1.deg2rad)(dD);
    var lonRad = (0, angleCalc_1.deg2rad)(lon);
    var hRad = muRad + lonRad - (dT / 13713.440924999626077);
    var xi = rhoCosLat * Math.sin(hRad);
    var eta = rhoSinLat * Math.cos(dRad) - rhoCosLat * Math.cos(hRad) * Math.sin(dRad);
    var zeta = rhoSinLat * Math.sin(dRad) + rhoCosLat * Math.cos(hRad) * Math.cos(dRad);
    var dXi = dMuRad * rhoCosLat * Math.cos(hRad);
    var dEta = dMuRad * xi * Math.sin(dRad) - zeta * dDRad;
    var u = x - xi;
    var v = y - eta;
    var a = dX - dXi;
    var b = dY - dEta;
    var n2 = Math.pow(a, 2) + Math.pow(b, 2);
    return { tMax: tMax, t0: t0, dT: dT, t: t, u: u, v: v, a: a, b: b, n2: n2 };
}
exports.getTimeLocalDependentCircumstances = getTimeLocalDependentCircumstances;
function iterateCircumstancesMaximumEclipse(besselianElements, location) {
    var t = 0;
    var tmp = 1;
    var cnt = 0;
    var circumstances = getTimeLocalDependentCircumstances(besselianElements, location, t);
    while (Math.abs(tmp) > 0.000001 && cnt < 50) {
        var u = circumstances.u, v = circumstances.v, a = circumstances.a, b = circumstances.b, n2 = circumstances.n2;
        tmp = (u * a + v * b) / n2;
        t -= tmp;
        circumstances = getTimeLocalDependentCircumstances(besselianElements, location, t);
        cnt++;
    }
    return circumstances;
}
exports.iterateCircumstancesMaximumEclipse = iterateCircumstancesMaximumEclipse;
function circumstancesToJulianDay(circumstances) {
    var tMax = circumstances.tMax, t0 = circumstances.t0, dT = circumstances.dT, t = circumstances.t;
    var jd = Math.floor(tMax - t0 / 24.0);
    t = t + t0 - ((dT - 0.05) / 3600.0);
    if (t < 0.0) {
        jd--;
    }
    else if (t >= 24.0) {
        jd++;
    }
    return jd + (t + 12) / 24;
}
exports.circumstancesToJulianDay = circumstancesToJulianDay;
