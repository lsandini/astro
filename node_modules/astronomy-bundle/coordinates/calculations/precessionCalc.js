"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.correctPrecessionForEquatorialCoordinates = exports.correctPrecessionForEclipticCoordinates = void 0;
var epoch_1 = require("../../constants/epoch");
var timeCalc_1 = require("../../time/calculations/timeCalc");
var angleCalc_1 = require("../../utils/angleCalc");
function correctPrecessionForEclipticCoordinates(coords, jd, startingEpoch) {
    if (startingEpoch === void 0) { startingEpoch = epoch_1.EPOCH_J2000; }
    var lonRad = (0, angleCalc_1.deg2rad)(coords.lon);
    var latRad = (0, angleCalc_1.deg2rad)(coords.lat);
    var T = (0, timeCalc_1.getEpochIntervalToJ2000)(startingEpoch);
    var t = (0, timeCalc_1.getEpochInterval)(jd, startingEpoch);
    var eta = ((0, angleCalc_1.sec2deg)(47.0029) - (0, angleCalc_1.sec2deg)(0.06603) * T + (0, angleCalc_1.sec2deg)(0.00006) * Math.pow(T, 2)) * t
        + ((0, angleCalc_1.sec2deg)(-0.03302) + (0, angleCalc_1.sec2deg)(0.000598) * T) * Math.pow(t, 2)
        + (0, angleCalc_1.sec2deg)(0.00006) * Math.pow(t, 3);
    var Pi = 174.876384 + (0, angleCalc_1.sec2deg)(3289.4789) * T + (0, angleCalc_1.sec2deg)(0.60622) * Math.pow(T, 2)
        - ((0, angleCalc_1.sec2deg)(869.8089) + (0, angleCalc_1.sec2deg)(0.50498) * T) * t
        + (0, angleCalc_1.sec2deg)(0.03536) * Math.pow(t, 2);
    var p = ((0, angleCalc_1.sec2deg)(5029.0966) + (0, angleCalc_1.sec2deg)(2.22226) * T - (0, angleCalc_1.sec2deg)(0.000042) * Math.pow(T, 2)) * t
        + ((0, angleCalc_1.sec2deg)(1.11113) - (0, angleCalc_1.sec2deg)(0.000042) * T) * Math.pow(t, 2)
        + (0, angleCalc_1.sec2deg)(0.000006) * Math.pow(t, 3);
    var etaRad = (0, angleCalc_1.deg2rad)(eta);
    var PiRad = (0, angleCalc_1.deg2rad)(Pi);
    var A = Math.cos(etaRad) * Math.cos(latRad) * Math.sin(PiRad - lonRad) - Math.sin(etaRad) * Math.sin(latRad);
    var B = Math.cos(latRad) * Math.cos(PiRad - lonRad);
    var C = Math.cos(etaRad) * Math.sin(latRad) + Math.sin(etaRad) * Math.cos(latRad) * Math.sin(PiRad - lonRad);
    var lon = p + Pi - (0, angleCalc_1.rad2deg)(Math.atan2(A, B));
    var lat = (0, angleCalc_1.rad2deg)(Math.asin(C));
    return {
        lon: (0, angleCalc_1.normalizeAngle)(lon),
        lat: lat,
        radiusVector: coords.radiusVector,
    };
}
exports.correctPrecessionForEclipticCoordinates = correctPrecessionForEclipticCoordinates;
function correctPrecessionForEquatorialCoordinates(coords, jd, startingEpoch) {
    if (startingEpoch === void 0) { startingEpoch = epoch_1.EPOCH_J2000; }
    var raRad = (0, angleCalc_1.deg2rad)(coords.rightAscension);
    var dRad = (0, angleCalc_1.deg2rad)(coords.declination);
    var T = (0, timeCalc_1.getEpochIntervalToJ2000)(startingEpoch);
    var t = (0, timeCalc_1.getEpochInterval)(jd, startingEpoch);
    var xi = ((0, angleCalc_1.sec2deg)(2306.2181) + (0, angleCalc_1.sec2deg)(1.39656) * T - (0, angleCalc_1.sec2deg)(0.000139) * Math.pow(T, 2)) * t
        + ((0, angleCalc_1.sec2deg)(0.30188) - (0, angleCalc_1.sec2deg)(0.000344) * T) * Math.pow(t, 2)
        + (0, angleCalc_1.sec2deg)(0.017988) * Math.pow(t, 3);
    var zeta = ((0, angleCalc_1.sec2deg)(2306.2181) + (0, angleCalc_1.sec2deg)(1.39656) * T - (0, angleCalc_1.sec2deg)(0.000139) * Math.pow(T, 2)) * t
        + ((0, angleCalc_1.sec2deg)(1.09468) + (0, angleCalc_1.sec2deg)(0.000066) * T) * Math.pow(t, 2)
        + (0, angleCalc_1.sec2deg)(0.018203) * Math.pow(t, 3);
    var theta = ((0, angleCalc_1.sec2deg)(2004.3109) - (0, angleCalc_1.sec2deg)(0.8533) * T - (0, angleCalc_1.sec2deg)(0.000217) * Math.pow(T, 2)) * t
        - ((0, angleCalc_1.sec2deg)(0.42665) + (0, angleCalc_1.sec2deg)(0.000217) * T) * Math.pow(t, 2)
        - (0, angleCalc_1.sec2deg)(0.041833) * Math.pow(t, 3);
    var xiRad = (0, angleCalc_1.deg2rad)(xi);
    var thetaRad = (0, angleCalc_1.deg2rad)(theta);
    var A = Math.cos(dRad) * Math.sin(raRad + xiRad);
    var B = Math.cos(thetaRad) * Math.cos(dRad) * Math.cos(raRad + xiRad) - Math.sin(thetaRad) * Math.sin(dRad);
    var C = Math.sin(thetaRad) * Math.cos(dRad) * Math.cos(raRad + xiRad) + Math.cos(thetaRad) * Math.sin(dRad);
    var rightAscension = (0, angleCalc_1.rad2deg)(Math.atan2(A, B)) + zeta;
    var declination = (0, angleCalc_1.rad2deg)(Math.asin(C));
    return {
        rightAscension: (0, angleCalc_1.normalizeAngle)(rightAscension),
        declination: declination,
        radiusVector: coords.radiusVector,
    };
}
exports.correctPrecessionForEquatorialCoordinates = correctPrecessionForEquatorialCoordinates;
