"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRhoCosLat = exports.getRhoSinLat = exports.getEquatorialParallax = exports.eclipticJ20002eclipticDate = exports.earthEclipticSpherical2sunEclipticSpherical = exports.rectangularGeocentric2rectangularHeliocentric = exports.rectangularHeliocentric2rectangularGeocentric = exports.equatorialSpherical2eclipticSpherical = exports.eclipticSpherical2equatorialSpherical = exports.equatorialSpherical2topocentricHorizontalByLocalHourAngle = exports.equatorialSpherical2topocentricHorizontal = exports.equatorialSpherical2topocentricSpherical = exports.spherical2rectangular = exports.rectangular2spherical = void 0;
var calculations_1 = require("../../earth/calculations");
var timeCalc_1 = require("../../time/calculations/timeCalc");
var angleCalc_1 = require("../../utils/angleCalc");
var dimensions_1 = require("../../earth/constants/dimensions");
var precessionCalc_1 = require("./precessionCalc");
function rectangular2spherical(coords) {
    var x = coords.x, y = coords.y, z = coords.z;
    var lonRad = Math.atan2(y, x);
    var lon = (0, angleCalc_1.normalizeAngle)((0, angleCalc_1.rad2deg)(lonRad));
    var latRad = Math.atan(z / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));
    var lat = (0, angleCalc_1.rad2deg)(latRad);
    var radiusVector = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));
    return { lon: lon, lat: lat, radiusVector: radiusVector };
}
exports.rectangular2spherical = rectangular2spherical;
function spherical2rectangular(coords) {
    var lon = coords.lon, lat = coords.lat, radiusVector = coords.radiusVector;
    var lonRad = (0, angleCalc_1.deg2rad)(lon);
    var latRad = (0, angleCalc_1.deg2rad)(lat);
    var x = radiusVector * Math.cos(latRad) * Math.cos(lonRad);
    var y = radiusVector * Math.cos(latRad) * Math.sin(lonRad);
    var z = radiusVector * Math.sin(latRad);
    return { x: x, y: y, z: z };
}
exports.spherical2rectangular = spherical2rectangular;
function equatorialSpherical2topocentricSpherical(coords, location, T) {
    var rightAscension = coords.rightAscension, declination = coords.declination, radiusVector = coords.radiusVector;
    var lat = location.lat, lon = location.lon, elevation = location.elevation;
    var dRad = (0, angleCalc_1.deg2rad)(declination);
    elevation = elevation || 0.0;
    var rhoSinLat = getRhoSinLat(lat, elevation);
    var rhoCosLat = getRhoCosLat(lat, elevation);
    var pi = getEquatorialParallax(radiusVector);
    var piRad = (0, angleCalc_1.deg2rad)(pi);
    var LAST = (0, timeCalc_1.getLocalApparentSiderealTime)(T, lon);
    var H = (0, timeCalc_1.getLocalHourAngle)(T, lon, rightAscension);
    var HRad = (0, angleCalc_1.deg2rad)(H);
    var A = Math.cos(dRad) * Math.sin(HRad);
    var B = Math.cos(dRad) * Math.cos(HRad) - rhoCosLat * Math.sin(piRad);
    var C = Math.sin(dRad) - rhoSinLat * Math.sin(piRad);
    var q = Math.sqrt(A * A + B * B + C * C);
    var HTopo = (0, angleCalc_1.rad2deg)(Math.atan2(A, B));
    var dTopoRad = Math.asin(C / q);
    return {
        rightAscension: (0, angleCalc_1.normalizeAngle)(LAST - HTopo),
        declination: (0, angleCalc_1.rad2deg)(dTopoRad),
        radiusVector: q * radiusVector,
    };
}
exports.equatorialSpherical2topocentricSpherical = equatorialSpherical2topocentricSpherical;
function equatorialSpherical2topocentricHorizontal(coords, location, T) {
    var rightAscension = coords.rightAscension, declination = coords.declination;
    var lat = location.lat, lon = location.lon;
    var topoCoords = equatorialSpherical2topocentricSpherical(coords, location, T);
    var H = (0, timeCalc_1.getLocalHourAngle)(T, lon, rightAscension);
    return equatorialSpherical2topocentricHorizontalByLocalHourAngle(H, declination, lat, topoCoords.radiusVector);
}
exports.equatorialSpherical2topocentricHorizontal = equatorialSpherical2topocentricHorizontal;
function equatorialSpherical2topocentricHorizontalByLocalHourAngle(localHourAngle, declination, lat, radiusVector) {
    if (radiusVector === void 0) { radiusVector = 0; }
    var HRad = (0, angleCalc_1.deg2rad)(localHourAngle);
    var dRad = (0, angleCalc_1.deg2rad)(declination);
    var latRad = (0, angleCalc_1.deg2rad)(lat);
    var ARad = Math.atan2(Math.sin(HRad), Math.cos(HRad) * Math.sin(latRad) - Math.tan(dRad) * Math.cos(latRad));
    var hRad = Math.asin(Math.sin(latRad) * Math.sin(dRad) + Math.cos(latRad) * Math.cos(dRad) * Math.cos(HRad));
    return {
        azimuth: (0, angleCalc_1.normalizeAngle)((0, angleCalc_1.rad2deg)(ARad) + 180),
        altitude: (0, angleCalc_1.rad2deg)(hRad),
        radiusVector: radiusVector,
    };
}
exports.equatorialSpherical2topocentricHorizontalByLocalHourAngle = equatorialSpherical2topocentricHorizontalByLocalHourAngle;
function eclipticSpherical2equatorialSpherical(coords, T, normalize) {
    if (normalize === void 0) { normalize = true; }
    var lon = coords.lon, lat = coords.lat, radiusVector = coords.radiusVector;
    var eps = calculations_1.earthCalc.getTrueObliquityOfEcliptic(T);
    var epsRad = (0, angleCalc_1.deg2rad)(eps);
    var lonRad = (0, angleCalc_1.deg2rad)(lon);
    var latRad = (0, angleCalc_1.deg2rad)(lat);
    var n = Math.sin(lonRad) * Math.cos(epsRad) - (Math.sin(latRad) / Math.cos(latRad)) * Math.sin(epsRad);
    var d = Math.cos(lonRad);
    var rightAscensionRad = Math.atan2(n, d);
    var rightAscension = normalize ? (0, angleCalc_1.normalizeAngle)((0, angleCalc_1.rad2deg)(rightAscensionRad)) : (0, angleCalc_1.rad2deg)(rightAscensionRad);
    var declinationRad = Math.asin(Math.sin(latRad) * Math.cos(epsRad) + Math.cos(latRad) * Math.sin(epsRad) * Math.sin(lonRad));
    var declination = (0, angleCalc_1.rad2deg)(declinationRad);
    return { rightAscension: rightAscension, declination: declination, radiusVector: radiusVector };
}
exports.eclipticSpherical2equatorialSpherical = eclipticSpherical2equatorialSpherical;
function equatorialSpherical2eclipticSpherical(coords, T) {
    var rightAscension = coords.rightAscension, declination = coords.declination, radiusVector = coords.radiusVector;
    var eps = calculations_1.earthCalc.getTrueObliquityOfEcliptic(T);
    var epsRad = (0, angleCalc_1.deg2rad)(eps);
    var rightAscensionRad = (0, angleCalc_1.deg2rad)(rightAscension);
    var declinationRad = (0, angleCalc_1.deg2rad)(declination);
    var n = Math.sin(rightAscensionRad) * Math.cos(epsRad) + Math.tan(declinationRad) * Math.sin(epsRad);
    var d = Math.cos(rightAscensionRad);
    var lonRad = Math.atan2(n, d);
    var lon = (0, angleCalc_1.normalizeAngle)((0, angleCalc_1.rad2deg)(lonRad));
    var latRad = Math.asin(Math.sin(declinationRad) * Math.cos(epsRad)
        - Math.cos(declinationRad) * Math.sin(epsRad) * Math.sin(rightAscensionRad));
    var lat = (0, angleCalc_1.rad2deg)(latRad);
    return { lon: lon, lat: lat, radiusVector: radiusVector };
}
exports.equatorialSpherical2eclipticSpherical = equatorialSpherical2eclipticSpherical;
function rectangularHeliocentric2rectangularGeocentric(heliocentricCoords, heliocentricCoordsEarth) {
    return {
        x: heliocentricCoords.x - heliocentricCoordsEarth.x,
        y: heliocentricCoords.y - heliocentricCoordsEarth.y,
        z: heliocentricCoords.z - heliocentricCoordsEarth.z,
    };
}
exports.rectangularHeliocentric2rectangularGeocentric = rectangularHeliocentric2rectangularGeocentric;
function rectangularGeocentric2rectangularHeliocentric(geocentricCoords, heliocentricCoordsEarth) {
    return {
        x: geocentricCoords.x + heliocentricCoordsEarth.x,
        y: geocentricCoords.y + heliocentricCoordsEarth.y,
        z: geocentricCoords.z + heliocentricCoordsEarth.z,
    };
}
exports.rectangularGeocentric2rectangularHeliocentric = rectangularGeocentric2rectangularHeliocentric;
function earthEclipticSpherical2sunEclipticSpherical(coordsEarth) {
    var lon = coordsEarth.lon, lat = coordsEarth.lat, radiusVector = coordsEarth.radiusVector;
    return {
        lon: (0, angleCalc_1.normalizeAngle)(lon + 180),
        lat: -1 * lat,
        radiusVector: radiusVector,
    };
}
exports.earthEclipticSpherical2sunEclipticSpherical = earthEclipticSpherical2sunEclipticSpherical;
function eclipticJ20002eclipticDate(lon, lat, radiusVector, T) {
    var jd = (0, timeCalc_1.julianCenturiesJ20002julianDay)(T);
    return (0, precessionCalc_1.correctPrecessionForEclipticCoordinates)({ lon: lon, lat: lat, radiusVector: radiusVector }, jd);
}
exports.eclipticJ20002eclipticDate = eclipticJ20002eclipticDate;
function getEquatorialParallax(d) {
    var angle = (0, angleCalc_1.deg2rad)((0, angleCalc_1.sec2deg)(8.794));
    var piRad = Math.asin(Math.sin(angle) / d);
    return (0, angleCalc_1.rad2deg)(piRad);
}
exports.getEquatorialParallax = getEquatorialParallax;
function getRhoSinLat(lat, elevation) {
    var latRad = (0, angleCalc_1.deg2rad)(lat);
    var uRad = Math.atan(dimensions_1.EARTH_AXIS_RATIO * Math.tan(latRad));
    return dimensions_1.EARTH_AXIS_RATIO * Math.sin(uRad) + elevation / dimensions_1.EARTH_RADIUS * Math.sin(latRad);
}
exports.getRhoSinLat = getRhoSinLat;
function getRhoCosLat(lat, elevation) {
    var latRad = (0, angleCalc_1.deg2rad)(lat);
    var uRad = Math.atan(dimensions_1.EARTH_AXIS_RATIO * Math.tan(latRad));
    return Math.cos(uRad) + elevation / dimensions_1.EARTH_RADIUS * Math.cos(latRad);
}
exports.getRhoCosLat = getRhoCosLat;
